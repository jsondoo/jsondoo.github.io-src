<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Breakout clone</title>
    <style>
        * { padding: 0; margin: 0; }
        canvas { background: #000; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="600" height="500"></canvas>

<script>
    // REFERENCE https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript
    // my code has some added changes
   
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d"); 

    var ballRadius = 10;
    var ballX = canvas.width/2;
    var ballY = canvas.height - 30;
    var dx = -3.5;
    var dy = -3.5;
    var ballColor = "#FFF";

    var paddleHeight = 10;
    var paddleWidth = 75;
    var paddleX = (canvas.width - paddleWidth) / 2;
    var paddledx = 5;
    var paddleColor ="#CDCDC9";

    var rightPressed = false;
    var leftPressed = false;

    var brickRowCount = 5;
    var brickColumnCount = 5;
    var brickWidth = 75;
    var brickHeight = 20;
    var brickPadding = 10;
    var brickOffsetTop = 30;
    var brickOffsetLeft = 10;
    var brickMoveRight = true;
    var brickMoveSpeed = 1;

    var bricks = [];
    for(c = 0; c < brickColumnCount; c++){
        bricks[c] = [];
        for(r = 0; r < brickRowCount; r++){
            bricks[c][r] = { x: 0, y: 0, status: 1}; // STATUS 1 = NOT HIT YET
        }
    }

    var score = 0;
    var gameOver = false;

    // main function
    function draw(){
        if(!gameOver) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBricks();
            drawBall();
            if (rightPressed && paddleX < canvas.width - paddleWidth) {
                paddleX += paddledx;
            }
            else if (leftPressed && paddleX > 0) {
                paddleX -= paddledx;
            }
            drawPaddle();
            drawScore();
            brickCollisionDetection();

            // better than setInterval, lets browser control framerate
            requestAnimationFrame(draw);
        }
        else{
            promptReplay();
        }
    }

    function promptReplay(){
        ctx.font = "12px Arial";
        ctx.fillStyle = "#FFF";
        ctx.fillText("Refresh the page to play again",80,160);
    }

    function drawScore(){
        ctx.font = "12px Arial";
        ctx.fillStyle = "#FFF";
        // last two parameters are coordinates
        ctx.fillText("Score: " + score, 8, 20);

        if(score == brickColumnCount * brickRowCount){
            stopGame();
            alert("You beat the game!");
            gameOver = true;
        }
    }

    function stopGame() {
        dx = 0;
        dy = 0;
        paddledx = 0;
    }

    function drawBricks(){
        if(brickMoveRight){
            brickOffsetLeft += brickMoveSpeed;
        }
        else{
            brickOffsetLeft -= brickMoveSpeed;
        }

        for(r = 0; r < brickRowCount; r++){
            ctx.beginPath();
            switch(r){
                case 0:
                    ctx.fillStyle = "red";
                    break;
                case 1:
                    ctx.fillStyle = "orange";
                    break;
                case 2:
                    ctx.fillStyle = "yellow";
                    break;
                case 3:
                    ctx.fillStyle = "#39FF14";
                    break;
                default:
                    ctx.fillStyle = "blue";
                    break;
            }
            for(c = 0; c < brickColumnCount; c++){
                // pretty cool way of arranging stuff
                if(bricks[c][r].status == 1) {
                    var brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                    var brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                    bricks[c][r].x = brickX;
                    bricks[c][r].y = brickY;

                    ctx.rect(brickX, brickY, brickWidth, brickHeight);
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }

        if(brickOffsetLeft >= 130){
            brickMoveRight = false;
        } else if(brickOffsetLeft <= 15){
            brickMoveRight = true;
        }
    }

    function brickCollisionDetection(){
        for(c = 0; c < brickColumnCount; c++){
            for(r = 0; r < brickRowCount; r++){
                var b = bricks[c][r];
                // collision if brickX < ballX < brickX + brickWidth
                // and also     brickY < ballY < brickY + brickHeight
                if(b.status == 1 &&
                    ballX > b.x && ballX < b.x + brickWidth &&
                        ballY > b.y && ballY < b.y + brickHeight){
                    dy = -dy;
                    b.status = 0;
                    score++;
                }

            }
        }
    }

    function drawBall(){
        ctx.beginPath();
        // x, y, arc radius, start angle, end angle (radian)
        ctx.arc(ballX,ballY,ballRadius,0, Math.PI*2);
        ctx.strokeStyle = "black";
        ctx.stroke();
        ctx.fillStyle = ballColor;
        ctx.fill();
        ctx.closePath();

        // collision handling
        if(ballX + dx > canvas.width - ballRadius || ballX + dx < ballRadius){
            dx = -dx;
        } else if(ballY + dy < ballRadius){
            dy = -dy;
        }
        else if (ballY + dy > canvas.height - ballRadius){
            if( ballX > paddleX && ballX < paddleX + paddleWidth){ // collision with paddle
                dy = -dy;
            }
            else {
                alert("Game over... Your score was " + score);
                gameOver = true;
                // document.location.reload();
            }
        }
        ballX+=dx;
        ballY+=dy;
    }

    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
        ctx.fillStyle = paddleColor;
        ctx.fill();
        ctx.closePath();
    }

    function keyDownHandler(e) {
        if(e.keyCode == 39) {
            rightPressed = true;
        }
        else if(e.keyCode == 37) {
            leftPressed = true;
        }
    }

    function keyUpHandler(e) {
        if(e.keyCode == 39) {
            rightPressed = false;
        }
        else if(e.keyCode == 37) {
            leftPressed = false;
        }
    }

    // keyboard control
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    // mouse control
    document.addEventListener("mousemove", mouseMoveHandler, false);
    function mouseMoveHandler(e){
        var relativeX = e.clientX - canvas.offsetLeft; // effective distance from canvas left edge to mouse pointer
        if(relativeX > 0 && relativeX < canvas.width) {
            paddleX = relativeX - paddleWidth/2;
        }
    }

    draw();
</script>

</body>
</html>
